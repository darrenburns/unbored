#!/usr/bin/env python
"""A simple terminal-based client for the Bored API.

http://www.boredapi.com/
"""

##############################################################################
# Python imports.
from datetime    import datetime
from typing      import Callable, Any, TypeVar, Final
from pathlib     import Path
from json        import dumps, loads, JSONEncoder
from dataclasses import is_dataclass, asdict

##############################################################################
# BoredAPI imports.
from bored_api import BoredClient, BoredActivity, ActivityType, BoredException

##############################################################################
# XDG imports.
from xdg import xdg_data_home

##############################################################################
# Textual imports.
from textual.app        import App, ComposeResult
from textual.css.query  import NoMatches
from textual.screen     import Screen
from textual.widget     import Widget
from textual.containers import Container, Horizontal, Vertical
from textual.widgets    import Header, Footer, Button, Static, Label, Input
from textual.binding    import Binding
from textual.message    import Message

##############################################################################
class ActivityEncoder( JSONEncoder ):
    """JSON encoder that understands about activities."""

    def default( self, o: object ):
        """Handle unknown values."""
        if is_dataclass( o ):
            return asdict( o )
        if isinstance( o, ActivityType ):
            return o.value
        return super().default( o )

##############################################################################
class Activity( Widget ):
    """A widget that holds and displays a suggested activity."""

    BINDINGS = [ Binding( "d", "delete", "Delete" ) ]
    """Bindings for the widget."""

    def __init__( self, activity: BoredActivity ):
        """Initialise the activity widget.

        Args:
            activity (BoredActivity): The activity to display.
        """
        super().__init__()
        self.activity  = activity
        self.chosen_at = datetime.now()

    def compose( self ) -> ComposeResult:
        """Compose the activity.

        Returns:
            ComposeResult: The layout for the main screen.
        """
        yield Static( self.chosen_at.strftime( '%c' ), classes="timestamp" )
        yield Static(
            f"[b]{self.activity.activity}[/b]\n\n"
            f"It's considered to have an accessibility of score of {self.activity.accessibility}"
            " (0 being the most accessible; 1 being the least), "
            f"is a {self.activity.type.value} type of activity, "
            + (
                f"requires {self.activity.participants} participants "
                if self.activity.participants > 1 else ""
            ) +
            f"and has a price score of {self.activity.price} (0 being free)."
        )
        yield Horizontal( Button( "Delete", variant="error" ), classes="buttons" )

    class Dropped( Message ):
        """A message to indicate that an activity was dropped."""

    async def drop_activity( self ):
        """Drop the current activity, letting the parent know we're doing so."""
        await self.emit( self.Dropped( self ) )
        await self.remove()

    async def on_button_pressed( self, event: Button.Pressed ) -> None:
        """React to a button being pressed on the widget."""
        event.stop()
        await self.drop_activity()

    async def action_delete( self ) -> None:
        """Delete action; removes this activity."""
        await self.drop_activity()

##############################################################################
class ValCastCheckInput( Input ):
    """An input widget that only accepts integer values."""

    CAST: Callable[ [ Any ], Any ] = str
    """Callable[ [ Any ], Any ]: The casting function.

    Note: It is expected that a `ValueError` will be raised if there is a
    problem with the value.
    """

    def __init__( self, *args: Any, **kwargs: Any ) -> None:
        """Initialise the input."""
        super().__init__( *args, **kwargs )
        # TODO: Workaround for https://github.com/Textualize/textual/issues/1216
        self.value = self.validate_value( self.value )

    def validate_value( self, value: str ) -> str:
        """Validate the input.

        Args:
            value (str): The value to validate.

        Returns:
            str: The acceptable value.
        """
        # If the input field isn't empty...
        if value.strip():
            try:
                # ...run it through the casting function. We don't care
                # about what comes out of the other end, we just case that
                # it makes it through at all.
                _ = self.CAST( value )
            except ValueError:
                # It's expected that the casting function will throw a
                # ValueError if there's a problem with the conversion (see
                # int and float for example) so, here we are. Make a
                # noise...
                self.app.bell()
                # ...and return what's in the input now because we're
                # rejecting the new value.
                return self.value
        # The value to test is either empty, or valid. Let's accept it.
        return value

##############################################################################
class IntInput( ValCastCheckInput ):
    """An input widget that only accepts integer float values."""

    CAST = int

##############################################################################
class FloatInput( ValCastCheckInput ):
    """An input widget that only accepts (most) float values."""

    CAST = float

TClamp = TypeVar( "TClamp", int, float )
"""A clampable type."""

##############################################################################
class Filters( Vertical ):
    """Filtering sidebar."""

    def compose( self ) -> ComposeResult:
        """Compose the filter panel.

        Returns:
            ComposeResult: The layout for the filters panel.
        """
        yield Label( "Filters", classes="h1" )
        yield Label( "Participants:", classes="h2" )
        yield IntInput( id="participants", placeholder="Number of participants" )
        yield Label( "Minimum Price:", classes="h2" )
        yield FloatInput( id="min_price", placeholder="Between 0 (free) and 1 (expensive)" )
        yield Label( "Maximum Price:", classes="h2" )
        yield FloatInput( id="max_price", placeholder="Between 0 (free) and 1 (expensive))" )
        yield Label( "Minimum Accessibility:", classes="h2" )
        yield FloatInput( id="min_accessibility", placeholder="Between 0 (most) and 1 (least)" )
        yield Label( "Maximum Accessibility:", classes="h2" )
        yield FloatInput( id="max_accessibility", placeholder="Between 0 (most) and 1 (least)" )

    @property
    def participants( self ) -> int | None:
        """int | None: The participants filter value.

        If the user appears to have provided a value, it will be an integer.
        If there is no given value or it doesn't look this will be `None`.
        """
        try:
            if ( value := int( self.query_one( "#participants", IntInput ).value.strip() ) ) > 0:
                return value
        except ValueError:
            pass
        return None

    @staticmethod
    def clamp( value: TClamp | None, min_val : TClamp, max_val: TClamp ) -> TClamp | None:
        """Clamp a value.

        Args:
            value (TClamp | None): The value to clamp.
            min_val (TClamp): The minimum value.
            max_val (TClamp): The maximum value.

        Returns:
            TClamp | None: The clamped value.

        Note:
            If the value is `None`, then `None` will be returned.
        """
        if value is None:
            return value
        if value < min_val:
            return min_val
        if value > max_val:
            return max_val
        return value

    def _min_max_value( self, value: str ) -> tuple[ float | None, float | None ]:
        """Get a min/max float value from the filters.

        Args:
            value (str): The name of the filter value to get.

        Returns:
            tuple[ float | None, float | None ]: The filter value.
        """
        def _value( which: str ) -> float | None:
            try:
                if ( price := float( self.query_one( f"#{which}_{value}", FloatInput ).value.strip() ) ) <= 0:
                    price = None
            except ValueError:
                price = None
            return price

        # Get the filter values.
        min_value = self.clamp( _value( "min" ), 0, 1 )
        max_value = self.clamp( _value( "max" ), 0, 1 )

        # Let's be nicer to a confused user, I guess.
        if min_value is not None and max_value is not None and max_value < min_value:
            return max_value, min_value

        # Finally, return what we've got.
        return min_value, max_value

    @property
    def price( self ) -> tuple[ float | None, float | None ]:
        """tuple[ float | None, float | None ]: The price filter.

        A tuple of minimum and maximum price filters. If no filter value was
        provided for either of the values then they will be `None`.
        """
        return self._min_max_value( "price" )

    @property
    def accessibility( self ) -> tuple[ float | None, float | None ]:
        """tuple[ float | None, float | None ]: The accessibility filter.

        A tuple of minimum and maximum accessibility filters. If no filter
        value was provided for either of the values then they will be
        `None`.
        """
        return self._min_max_value( "accessibility" )

##############################################################################
class TypeChoices( Container ):

    def compose( self ) -> ComposeResult:
        """Compose the type choices button collection.

        Returns:
            ComposeResult: The layout for the type choice buttons.
        """
        yield Button( "Any", id="any" )
        yield from ( Button(
            activity.value.capitalize(), id=activity.value
        ) for activity in ActivityType )

##############################################################################
class Main( Screen ):
    """The main application screen."""

    BINDINGS = [
        Binding( "f", "filters", "Filters" ),
        Binding( "escape", "close", "Close" )
    ]
    """The bindings for the main screen."""

    def compose( self ) -> ComposeResult:
        """Compose the main screen.

        Returns:
            ComposeResult: The layout for the main screen.
        """
        yield Header()
        self.activities = Vertical( id="activities" )
        yield Vertical( TypeChoices(), self.activities )
        yield Footer()
        self.filters = Filters( classes="hidden" )
        yield self.filters

    def on_mount( self ) -> None:
        """Set up the screen on mount."""
        self.api = BoredClient()
        self.set_focus( self.query_one( "#any", Button ) )
        self.load_activity_list()

    ACTIVITY_FILE: Final = Path( "unboard.json" )
    """Path: The name of the file that the list it saved to."""

    @property
    def data_file( self ) -> Path:
        """Path: The full path to the file for saving the data.

        Note:
            As a side effect of access the directory will be crated if it
            doesn't exist.
        """
        ( save_to := xdg_data_home() / "unboard" ).mkdir( parents=True, exist_ok=True )
        return save_to / self.ACTIVITY_FILE

    def save_activity_list( self ) -> None:
        """Save the activity list to disk."""
        self.data_file.write_text( dumps(
            [ activity.activity for activity in self.activities.query( Activity ) ],
            cls=ActivityEncoder, indent=4
        ) )

    def load_activity_list( self ) -> None:
        """Load the activity list from disk."""
        if self.data_file.exists():
            to_mount: list[ Activity ] = []
            for activity in loads( self.data_file.read_text() ):
                activity[ "type" ] = ActivityType( activity[ "type" ] )
                to_mount.append( Activity( BoredActivity( **activity ) ) )
            if to_mount:
                self.activities.mount( *to_mount )

    async def on_button_pressed( self, event: Button.Pressed ) -> None:
        """Handle the button press."""

        # We're going to build up a collection of options to dictate the
        # choice made.
        options: dict[ str, int | float | str ] = {}

        # If the button wasn't the any button, it'll have been one of the
        # activity type buttons. The filter value is in the button ID.
        if event.button.id is not None and event.button.id != "any":
            options[ "type" ] = event.button.id

        # If it looks like we've got a participants filter...
        if ( participants := self.filters.participants ) is not None:
            # ...add that.
            options[ "participants" ] = participants

        # See if we should apply price filtering.
        min_price, max_price = self.filters.price
        if min_price is not None:
            options[ "min_price" ] = min_price
        if max_price is not None:
            options[ "max_price" ] = max_price

        # See if we should apply accessibility filtering.
        min_accessibility, max_accessibility = self.filters.accessibility
        if min_accessibility is not None:
            options[ "min_accessibility" ] = min_accessibility
        if max_accessibility is not None:
            options[ "max_accessibility" ] = max_accessibility

        # Get the new activity.
        try:
            self.activities.mount(
                Activity( await self.api.get( **options ) ), before=0
            )
            self.save_activity_list()
        except BoredException:
            self.activities.mount(
                Static( "No activities match the filters; TODO: display this better" ),
                before=0
            )

    def action_close( self ) -> None:
        """Handle the close action."""

        # There's two ways the filters can appear, either by pulling them up
        # with the binding, or by tabbing into the offscreen sidebar (I feel
        # that this should not really be possible -- it feels like it should
        # be possible to disable a tab-set in bulk, but anyway...). Here I
        # look to see if focus is within the filters and, if it is, set
        # focus back on the main button and also ensure that the hidden
        # class is removed from the filters, before...
        try:
            _ = self.query_one( "Filters:focus-within" )
            self.set_focus( self.query_one( "#any", Button ) )
            self.filters.remove_class( "hidden" )
        except NoMatches:
            pass

        # ...checking if the filters are hidden. If they are...
        if self.filters.has_class( "hidden" ):
            # ...escape bails on the app.
            self.app.exit()
        else:
            # ...otherwise we toggle the filters.
            self.action_filters()

    def action_filters( self ) -> None:
        """Toggle the display of the filters."""
        self.filters.toggle_class( "hidden" )
        if not self.filters.has_class( "hidden" ):
            self.filters.query( Input ).first().focus()

    def on_activity_dropped( self, _: Activity.Dropped ):
        """React to an activity being dropped."""
        self.save_activity_list()

##############################################################################
class Unbored( App[ None ] ):
    """The main application class."""

    CSS_PATH = "unbored.css"
    """The name of the CSS file for the application."""

    TITLE = "Unbored"
    """The title of the application."""

    SCREENS = {
        "main": Main
    }
    """The collection of application screens."""

    def on_mount( self ) -> None:
        """Set up the application on startup."""
        self.push_screen( "main" )

##############################################################################
# Main entry point.
if __name__ == "__main__":
    Unbored().run()

### unbored ends here
