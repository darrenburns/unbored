#!/usr/bin/env python

##############################################################################
# Python imports.
from datetime import datetime
from typing   import Callable, Any

##############################################################################
# BoredAPI imports.
from bored_api import BoredClient, BoredActivity, ActivityType

##############################################################################
# Textual imports.
from textual.app        import App, ComposeResult
from textual.css.query  import NoMatches
from textual.screen     import Screen
from textual.widget     import Widget
from textual.containers import Container, Horizontal, Vertical
from textual.widgets    import Header, Footer, Button, Static, Label, Input
from textual.binding    import Binding

##############################################################################
class Activity( Widget ):
    """A widget that holds and displays a suggested activity."""

    BINDINGS = [ Binding( "d", "delete", "Delete" ) ]
    """Bindings for the widget."""

    def __init__( self, activity: BoredActivity ):
        """Initialise the activity widget.

        Args:
            activity (BoredActivity): The activity to display.
        """
        super().__init__()
        self.activity  = activity
        self.chosen_at = datetime.now()

    def compose( self ) -> ComposeResult:
        """Compose the activity.

        Returns:
            ComposeResult: The layout for the main screen.
        """
        yield Static( self.chosen_at.strftime( '%c' ), classes="timestamp" )
        yield Static(
            f"[b]{self.activity.activity}[/b]\n\n"
            f"It's considered to have an accessibility of score of {self.activity.accessibility}"
            " (0 being the most accessible; 1 being the least), "
            f"is a {self.activity.type.value} type of activity, "
            + (
                f"requires {self.activity.participants} participants "
                if self.activity.participants > 1 else ""
            ) +
            f"and has a price score of {self.activity.price} (0 being free)."
        )
        yield Horizontal( Button( "Delete", variant="error" ), classes="buttons" )

    def on_button_pressed( self, event: Button.Pressed ) -> None:
        """React to a button being pressed on the widget."""
        event.stop()
        self.remove()

    def action_delete( self ) -> None:
        """Delete action; removes this activity."""
        self.remove()

##############################################################################
class ValCastCheckInput( Input ):
    """An input widget that only accepts integer values."""

    CAST: Callable[ [ Any ], Any ] = str
    """Callable[ [ Any ], Any ]: The casting function.

    Note: It is expected that a `ValueError` will be raised if there is a
    problem with the value.
    """

    def __init__( self, *args: Any, **kwargs: Any ) -> None:
        """Initialise the input."""
        super().__init__( *args, **kwargs )
        # TODO: Workaround for https://github.com/Textualize/textual/issues/1216
        self.value = self.validate_value( self.value )

    def validate_value( self, value: str ) -> str:
        """Validate the input.

        Args:
            value (str): The value to validate.

        Returns:
            str: The acceptable value.
        """
        # If the input field isn't empty...
        if value.strip():
            try:
                # ...run it through the casting function. We don't care
                # about what comes out of the other end, we just case that
                # it makes it through at all.
                _ = self.CAST( value )
            except ValueError:
                # It's expected that the casting function will throw a
                # ValueError if there's a problem with the conversion (see
                # int and float for example) so, here we are. Make a
                # noise...
                self.app.bell()
                # ...and return what's in the input now because we're
                # rejecting the new value.
                return self.value
        # The value to test is either empty, or valid. Let's accept it.
        return value

##############################################################################
class IntInput( ValCastCheckInput ):
    """An input widget that only accepts integer float values."""

    CAST = int

##############################################################################
class FloatInput( ValCastCheckInput ):
    """An input widget that only accepts (most) float values."""

    CAST = float

##############################################################################
class Filters( Vertical ):
    """Filtering sidebar."""

    def compose( self ) -> ComposeResult:
        """Compose the filter panel.

        Returns:
            ComposeResult: The layout for the filters panel.
        """
        yield Label( "Filters", classes="h1" )
        yield Label( "Participants:", classes="h2" )
        yield IntInput( placeholder="Max Participants" )
        yield Label( "Min Price:", classes="h2" )
        yield IntInput( placeholder="Minimum Price" )
        yield Label( "Max Price:", classes="h2" )
        yield IntInput( placeholder="Maximum Price" )
        yield Label( "Min Accessibility:", classes="h2" )
        yield FloatInput( placeholder="Minimum Accessibility" )
        yield Label( "Max Accessibility:", classes="h2" )
        yield FloatInput( placeholder="Maximum Accessibility" )

##############################################################################
class TypeChoices( Container ):

    def compose( self ) -> ComposeResult:
        yield Button( "Any", id="any" )
        yield from ( Button(
            activity.value.capitalize(), id=activity.value
        ) for activity in ActivityType )

##############################################################################
class Main( Screen ):
    """The main application screen."""

    BINDINGS = [
        Binding( "f", "filters", "Filters" ),
        Binding( "escape", "close", "Close" )
    ]
    """The bindings for the main screen."""

    def compose( self ) -> ComposeResult:
        """Compose the main screen.

        Returns:
            ComposeResult: The layout for the main screen.
        """
        yield Header()
        yield Vertical( TypeChoices(), Vertical( id="activities" ) )
        yield Footer()
        yield Filters( classes="hidden" )

    def on_mount( self ):
        """Set up the screen on mount."""
        self.api = BoredClient()
        self.set_focus( self.query_one( "#any", Button ) )

    async def on_button_pressed( self, event: Button.Pressed ):
        """Handle the button press."""

        # We're going to build up a collectio of options to dictate the
        # choice made.
        options = {}

        # If the button wasn't the any button, it'll have been one of the
        # activity type buttons. The filter value is in the button ID.
        if event.button.id != "any":
            options[ "type" ] = event.button.id

        # Get the new activity.
        self.query_one( "#activities" ).mount(
            Activity( await self.api.get( **options ) ), before=0
        )

    def action_close( self ) -> None:
        """Handle the close action."""

        # There's two ways the filters can appear, either by pulling them up
        # with the binding, or by tabbing into the offscreen sidebar (I feel
        # that this should not really be possible -- it feels like it should
        # be possible to disable a tab-set in bulk, but anyway...). Here I
        # look to see if focus is within the filters and, if it is, set
        # focus back on the main button and also ensure that the hidden
        # class is removed from the filters, before...
        try:
            _ = self.query_one( "Filters:focus-within" )
            self.set_focus( self.query_one( "#any", Button ) )
            self.query_one( Filters ).remove_class( "hidden" )
        except NoMatches:
            pass

        # ...checking if the filters are hidden. If they are...
        if self.query_one( Filters ).has_class( "hidden" ):
            # ...escape bails on the app.
            self.app.exit()
        else:
            # ...otherwise we toggle the filters.
            self.action_filters()

    def action_filters( self ) -> None:
        """Toggle the display of the filters."""
        self.query_one( Filters ).toggle_class( "hidden" )

##############################################################################
class Unbored( App[ None ] ):
    """The main application class."""

    CSS_PATH = "unbored.css"
    """The name of the CSS file for the application."""

    TITLE = "Unbored"
    """The title of the application."""

    SCREENS = {
        "main": Main
    }
    """The collection of application screens."""

    def on_mount( self ) -> None:
        """Set up the application on startup."""
        self.push_screen( "main" )

##############################################################################
# Main entry point.
if __name__ == "__main__":
    Unbored().run()

### unbored ends here
